import numpy as np
from scipy.optimize import curve_fit
from .pbls import pbls_search

def gaussian_with_offset(x: np.ndarray, offset: float, amp: float,
                         mu: float, sigma: float) -> np.ndarray:
    """Gaussian plus constant offset model."""
    return offset + amp * np.exp(-0.5 * ((x - mu) / sigma) ** 2)



def find_contiguous_width(x: np.ndarray, y: np.ndarray, idx: int,
                          baseline: float) -> float:
    """Estimate width around a peak where y > baseline.

    Generated by ChatGPT o4-mini on June 11 2025.
    
    Args:
        x: Period axis array.
        y: Power axis array.
        idx: Index of the peak in arrays.
        baseline: Baseline power threshold.
    
    Returns:
        Approximate full width of contiguous region above baseline.
    """
    n = len(x)
    left = idx
    while left > 0 and y[left] > baseline:
        left -= 1
    right = idx
    while right < n - 1 and y[right] > baseline:
        right += 1
    return x[right] - x[left]


def fit_and_subtract_peaks(x: np.ndarray, y: np.ndarray) -> dict:
    """Iteratively fit and subtract peaks until criteria met.

    Generated by ChatGPT o4-mini on June 11 2025.
    
    Args:
        x: Period axis array.
        y: Power axis array (modified in place).
    
    Returns:
        A dict mapping iteration index to a dict with keys:
        'offset','amp','mu','sigma','fwhm','baseline','x','y_start','residual'
    """
    baseline = np.nanpercentile(y, 25)
    results = {}
    fits = 0

    for iter_idx in range(10):
        # cache x and y at start of iteration
        x_start = x.copy()
        y_start = y.copy()

        peak_idx = np.argmax(y)
        peak_power = y[peak_idx]
        peak_period = x[peak_idx]
        if peak_power <= 0:
            break

        width = find_contiguous_width(x, y, peak_idx, baseline)
        window_half = 0.34 * width
        mask = np.abs(x - x[peak_idx]) <= window_half

        # initial guesses: offset, amp, mu, sigma
        p0 = [baseline, peak_power - baseline,
              x[peak_idx], width / (2 * np.sqrt(2 * np.log(2)))]
        bounds = ([0, 0, x[peak_idx] - window_half, 0],
                  [np.inf, np.inf, x[peak_idx] + window_half, 2])

        popt, _ = curve_fit(gaussian_with_offset,
                            x[mask], y[mask], p0=p0, bounds=bounds)

        offset, amp, mu, sigma = popt
        fwhm = 2 * np.sqrt(2 * np.log(2)) * sigma

        print(f"Peak at {mu:.4f} d: power={offset+amp:.3f}, "
              f"FWHM={fwhm:.4f} d")

        fits += 1

        # subtract Gaussian model where y > baseline
        model_vals = gaussian_with_offset(x[mask], *popt)
        subtract_mask = mask & (y > baseline)
        model = gaussian_with_offset(x[subtract_mask], *popt)
        y[subtract_mask] -= model

        # cache residual and all parameters
        residual = y.copy()
        results[iter_idx] = {
            'peak_idx': peak_idx,
            'peak_power': peak_power,
            'peak_period': peak_period,
            'offset': offset,
            'amp': amp,
            'mu': mu,
            'sigma': sigma,
            'fwhm': fwhm,
            'baseline': baseline,
            'x': x_start,
            'y_start': y_start,
            'model': model,
            'subtract_mask': subtract_mask,
            'residual': residual,
        }

        # check break criteria
        if fwhm < 0.05 and (offset + amp) > 7:
            print("Found narrow, high-SNR peak; stopping.")
            found_narrow_peak = True
            results[iter_idx]['found_narrow_peak'] = found_narrow_peak
            return results

        if fits >= 10:
            print("Reached 10 iterations; giving up.")
            found_narrow_peak = False
            results[iter_idx]['found_narrow_peak'] = found_narrow_peak
            return results

    print("No more peaks or zeroed out; done.")
    return results